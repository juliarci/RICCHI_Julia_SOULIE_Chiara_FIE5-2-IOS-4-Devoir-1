---
title: "FIA5-2-IOS-5 Devoir 1"
author: "Adrien Wartelle"
date: "2026-01-11"
output:
  pdf_document: default
  html_document:
    df_print: paged
editor_options: 
  markdown: 
    wrap: sentence
---

# Etude de cas sur l’analyse et la mesure de performance des Flux de Patients

## Introduction

Ce travail porte sur l'analyse des flux de patients sur un plateau mutualisé de consultations externes d'un hôpital.
L'objectif est de réaliser un diagnostic objectif de la performance organisationnelle du service d'urologie en s'appuyant sur les méthodes et outils d'analyse de flux vus précédemment ainsi que sur le langage R à travers l’environnement de RStudio.
La figure ci-dessous illustre les principaux flux ainsi que le Plan du plateau de consultations (voir fichiers PlanConsultations.pdf et ZoomURO.pdf consultables à partir <http://bit.ly/PlansCHUTlse>)

<!--<img src="illustrations/PlanUro.png" alt="Plan du plateau de consultations" width="600"/>-->

![Plan du plateau de consultations](illustrations/PlanUro.png "Plan du plateau de consultations") Afin de collecter des données sur les parcours suivis, les patients qui se sont présentés le 12/11/2015 ont été équipés d’une étiquette électronique (type RFID) qui a permis de tracer leurs parcours dans le plateau de consultation.
Les données collectées ont été fusionnées avec les données des outils de gestion des dossiers administratifs et médicaux utilisés par les personnels.
L'ensemble est disponible sous la forme d’un fichier log, illustré par le tableau suivant (voir annexe LogPatientUROseul_12112015.xlsx consultable à partir <http://bit.ly/logPatients>).

<!--<img src="illustrations/TableauLogPatients.png" alt="Vue du tableau de données de log patient" width="600"/>-->

![*Vue du tableau de données de log patient*](illustrations/TableauLogPatients.png "Vue du tableau de données de log patient")

Les différentes de ce tableau de données sont :

-   *ID* (Col A) : Identifiant du patient

-   *Timestamp start* (Col B) : horodatage entrée de zone ou salle

-   *Timestamp end* (Col C) : horodatage sortie de zone ou salle

-   *Activity_MACRO* (Col D) : Activité suivie et indice salle (i)

-   *Activity_DETAILS* (Col E) : Type d'activité

-   *Ress.Humaines* (Col F) : Ressources humaines administratives ou soignantes intervenant dans l'activité

-   *distance parcourues* (Col G) : Distance parcourue cumulée

-   *début/fin opX* (Col H à O) : horodatage début/fin de chaque opération de prise en charge par une ressource administrative ou soignante (maxi 4 opérations par activité).

## **Devoir 1 - Travail demandé** : Exploration de Données Exploratoires

Ce travail est à rendre pour le **08/02/2026** au format Rmd ou R (+pdf si besoin) avec pour titre "NOM_Prenom_FIE5-2-IOS-4-Devoir-1.\*"

Ce premier devoir consiste en une exploration initiale des données afin de : - Comprendre les données - Structurer les données - Effectuer une analyse descriptive des données - Synthétiser une vision du service d'Urologie

```{r include=FALSE}
library(tidyverse)
library(data.table)

load("local_data/trace_example_1.RData")
load("local_data/trace_example_final.RData")

```

### Question 1) Mise en forme des données (*Preprocessing*) (/6)

Avant toute forme d'analyse et de modélisation, une grande partie du travail réside dans la préparation des données.
Il faut ainsi mettre les données dans un format qui soit plus simple à exploiter.
Ici, on cherche à obtenir les données avec les colonnes / variables suivantes :

-   *ID* (character) : Identifiant du patient ou de l'acteur en chaîne de caractères

-   TYPE (factor) : Distingue le type d'agent par les facteurs PATIENT et ACTOR

-   CURRENT_LOCATION (character) : Identifie la localisation actuelle (ou source)

-   Les localisations ont été renommées avec :

    ```         
    c("Entree_Generale","Accueil_Prio_1","Accueil_General_1", "Accueil_General_2","Accueil_General_3","Accueil_Attente", "Sortie_Attente","Sortie_Bureau_1","Sortie_Bureau_2", "Sortie_Generale","Uro_Box_1","Uro_Box_2","Uro_Box_3", "Uro_Box_4","Uro_Box_5","Uro_Box_6","Uro_Box_7", "Uro_Bureau_Annonce_1","Uro_Bureau_IDE_1","Uro_Debimetrie_1", "Uro_Examen_1","Uro_Examen_2","Uro_Examen_3","Uro_Attente_1")
    ```

-   NEXT_LOCATION (character) : Prochaine localisation (lorsque l'agent est en déplacement)

-   CURRENT_OPERATION_NUMBER (numeric) : étape d'opération

-   WITH_1 (character) : agent avec lequel l'agent concerné est en train d'interagir (patient avec acteur ou acteur avec patient)

-   WITH_2 (character) : 2ème agent avec lequel l'agent concerné est en train d'interagir (patient avec acteur ou acteur avec patient)

-   DATETIME_BEGIN (datetime) : Date de début de l'état courant

-   DATETIME_END (datetime) : Date de fin de l'état courant et de début du prochain état

Voici un extrait de ce qu'il faut obtenir, ici filtrer sur le patient d'ID 8 :

```{r example trace}
trace_example_1 
```

#### Réponse :

*Ci-dessous le code R de formattage de la table :*

```{r answer 1.a}

library(dplyr)
library(readxl)
library(tidyverse)

# Load the Excel dataset Patient URO
df <- read_excel("Log_Patient_URO_12112015.xlsx")
# df

# See dataFrame column names
names(df)

# Rename columns for easier handling
df1 <- df %>%
   rename(Ress_Humaines = `Ress. Humaines`,
        Timestamp_start = `Timestamp start`,
        Timestamp_end   = `Timestamp end`,
        DISTANCE_PARCOURUE = `distance parcourue`)

# Add a TYPE column with "PATIENT" for all rows
df1 <- df1 %>%
  mutate(
    TYPE = "PATIENT"
    )
# df1

# Copy dataframe
df2 <- df1

# Pivot the timestamp columns into a long format
df3 <- df2 %>%
  transmute(ID, TYPE, Activity_DETAILS, DISTANCE_PARCOURUE,
            t0 = Timestamp_start,
            t1 = `début op1`,
            t2 = `fin op1`,
            t3 = `début op2`,
            t4 = `fin op2`,
            t5 = `début op3`,
            t6 = `fin op3`,
            t7 = `début op4`,
            t8 = `fin op4`,
            t9 = Timestamp_end, Ress_Humaines) %>%
#  filter(ID == 8) %>%
  group_by(ID) %>%
  gather(key = "type", value = "time", t0:t9) %>%
  filter(time > as_datetime("2015-11-12 00:01:00")) %>%
  arrange(ID, time) %>%
  mutate(next_time = lead(time)) %>%
  filter(!is.na(time))
# df3

# Map old activity names to new ones
place_table <- tibble(
  Activity_DETAILS = c("Entrée des Consultations",
    "ACCUEIL.Bureau_AccueilPRIO(1)","ACCUEIL.Bureau_Accueil(1)",
    "ACCUEIL.Bureau_Accueil(2)","ACCUEIL.Bureau_Accueil(3)",
    "ACCUEIL.S_Attente_Accueil(1)",
    "SORTIE_URO.File_Attente(1)","SORTIE_URO_Bureau_Sortie(1)",
    "SORTIE_URO.Bureau_Sortie(2)","Sortie des Consultations",
    "URO.Box_Consult(1)","URO.Box_Consult(2)","URO.Box_Consult(3)",
    "URO.Box_Consult(4)","URO.Box_Consult(5)","URO.Box_Consult(6)",
    "URO.Box_Consult(7)","URO.Bureau_Annonce(1)","URO.Bureau_IDE(1)",
    "URO.Salle_Débitmétrie(1)","URO.Salle_Examen(1)",
    "URO.Salle_Examen(2)","URO.Salle_Examen(3)","URO.S_Attente_5(1)"),
  place = c("Entree_Generale","Accueil_Prio_1","Accueil_General_1",
            "Accueil_General_2","Accueil_General_3","Accueil_Attente",
            "Sortie_Attente","Sortie_Bureau_1","Sortie_Bureau_2",
            "Sortie_Generale","Uro_Box_1","Uro_Box_2","Uro_Box_3",
            "Uro_Box_4","Uro_Box_5","Uro_Box_6","Uro_Box_7",
            "Uro_Bureau_Annonce_1","Uro_Bureau_IDE_1","Uro_Debimetrie_1",
            "Uro_Examen_1","Uro_Examen_2","Uro_Examen_3","Uro_Attente_1"))

# Map old activity names to new ones using place_table
df3 <- df3 %>%
  left_join(place_table, by = "Activity_DETAILS") %>%
  rename(CURRENT_LOCATION = place)

# Check mapping
unique(df3$CURRENT_LOCATION)

# Arrange by time and create NEXT_LOCATION
df4 <- df3 %>%
  arrange(time) %>%
  mutate(
    NEXT_LOCATION = lead(CURRENT_LOCATION)
  )

# df4


# Add CURRENT_LOCATION column
df4 <- df4 %>% mutate(NEXT_LOCATION = lead(CURRENT_LOCATION))

# df4

# Create column that indicates the current step for each patient.
df5 <- df4 %>%
  mutate(
    CURRENT_OPERATION_NUMBER = case_when(
      str_detect(type, "t1") ~ 1,  # début ou fin op1
      str_detect(type, "t3") ~ 2,  # début ou fin op2
      str_detect(type, "t5") ~ 3,  # début ou fin op3
      str_detect(type, "t7") ~ 4,  # début ou fin op4
      TRUE ~ NA_integer_
    )
  )
# df5

# Extract the relevant resources for each operation
df6 <- df5 %>%
  mutate(
    RESSOURCE_OP = case_when(
      # Cas simple : pas d'opération
      !str_detect(Ress_Humaines, "Op\\d") & str_detect(type, "t1|t3|t5|t7|t9")  ~ Ress_Humaines,

      # Op1
      str_detect(type, "t1") ~ str_sub(
        str_extract(Ress_Humaines, "Op1\\s*:\\s*([^-])*\\s*-"),
        7L, -3L
      ),

      # Op2
      str_detect(type, "t3") ~ str_sub(
        str_extract(Ress_Humaines, "Op2\\s*:\\s*([^-])*\\s*-"),
        7L, -3L
      ),

      # Op3
      str_detect(type, "t5") ~ str_sub(
        str_extract(Ress_Humaines, "Op3\\s*:\\s*([^-])*\\s*-"),
        7L, -3L
      ),

      # Op4
      str_detect(type, "t7") ~ str_sub(
        str_extract(Ress_Humaines, "Op4\\s*:\\s*([^-])*\\s*-"),
        7L, -3L
      ),
      
       # Op5
      str_detect(type, "t9") ~ str_sub(
        str_extract(Ress_Humaines, "Op5\\s*:\\s*([^-])*\\s*-"),
        7L, -3L
      ),

      TRUE ~ NA_character_
    )
  )
# df6

# Split resources into WITH_1 and WITH_2 if " et " present
df7 <- df6 %>%
  mutate(
    WITH_1 = sapply(str_split(RESSOURCE_OP, " et "), `[`, 1),
    WITH_2 = sapply(str_split(RESSOURCE_OP, " et "), `[`, 2)
  ) %>%
  select(-RESSOURCE_OP)
# df7

# Build final dataframe for patients
final_df <- df7 %>%
  transmute(
    ID = as.character(ID),
    TYPE,
    CURRENT_LOCATION = as.character(CURRENT_LOCATION),
    NEXT_LOCATION    = as.character(NEXT_LOCATION),
    CURRENT_OPERATION_NUMBER,
    WITH_1 = as.character(WITH_1),
    WITH_2 = as.character(WITH_2),
    DATETIME_BEGIN = time,
    DATETIME_END   = next_time,
    DISTANCE_PARCOURUE = as.numeric(DISTANCE_PARCOURUE)
  )

# final_df

final_df_ID_8 <- final_df %>%
  mutate(
    ID = as.character(ID),
    WITH_1 = as.character(WITH_1),
    WITH_2 = as.character(WITH_2)
  ) %>% filter(ID == 8)

final_df_ID_8
```

**Résultat :**

A la suite des différentes étapes de préparation des données nous sommes arrivées à la table ci dessus, filtrée sur le patient ayant l'ID 8.
Il est nécessaire maintenant de rajouter les acteurs dans cette table en inversant les données du tableaux puis en rajoutan les lignes correspondantes.

```{r answer 1.b}

# Create ACTOR entities based on patient interactions
actors <- final_df %>%
  filter(TYPE == "PATIENT") %>%
  filter(!is.na(WITH_1)) %>%
  mutate(
    WITH_2 = NA,
    WITH_3 = ID,
    ID = WITH_1,
    WITH_1 = WITH_3,
    TYPE = "ACTOR",
    DISTANCE_PARCOURUE = NA
  ) %>%
  select(-WITH_3) %>%
  rbind(
    final_df %>%
      filter(TYPE == "PATIENT") %>%
      filter(!is.na(WITH_2)) %>%
      mutate(
        WITH_1 = NA,
        WITH_3 = ID,
        ID = WITH_2,
        WITH_1 = WITH_3,
        TYPE = "ACTOR",
        DISTANCE_PARCOURUE = NA
      ) %>%
      select(-WITH_3)
  ) %>%
  arrange(ID, DATETIME_BEGIN)

# Combine patient and actor traces into a full event log
trace_full <- bind_rows(final_df, actors) %>%
  arrange(ID, DATETIME_BEGIN)


# Build actor activity, idle, and mirror traces
actors_base <- final_df %>%
  filter(TYPE == "PATIENT") %>%
  mutate(PATIENT_ID = ID) %>%                
  pivot_longer(
    cols = c(WITH_1, WITH_2),
    values_to = "ACTOR_ID",
    names_to = "src"
  ) %>%
  filter(!is.na(ACTOR_ID)) %>%
  transmute(
    ID = ACTOR_ID,
    TYPE = "ACTOR",
    CURRENT_LOCATION,
    NEXT_LOCATION,
    CURRENT_OPERATION_NUMBER,
    WITH_1 = PATIENT_ID,                      
    WITH_2 = NA_character_,
    DATETIME_BEGIN,
    DATETIME_END,
    DISTANCE_PARCOURUE = NA_real_
  ) %>%
  distinct(ID, CURRENT_OPERATION_NUMBER, DATETIME_BEGIN, .keep_all = TRUE) %>%
  arrange(ID, DATETIME_BEGIN)

# Identify idle periods for each actor (end of previous activity to start of next one)
actor_idle <- actors_base %>%
  group_by(ID) %>%
  arrange(CURRENT_OPERATION_NUMBER) %>%
  mutate(
    idle_begin = lag(DATETIME_END),
    idle_end   = DATETIME_BEGIN,
    idle_op    = lag(CURRENT_OPERATION_NUMBER),
    idle_loc   = lag(CURRENT_LOCATION)
  ) %>%
  filter(!is.na(idle_begin) & idle_begin < idle_end) %>%
  transmute(
    ID,
    TYPE = "ACTOR",
    CURRENT_LOCATION = idle_loc,
    NEXT_LOCATION    = idle_loc,
    CURRENT_OPERATION_NUMBER = idle_op,
    WITH_1 = NA_character_,
    WITH_2 = NA_character_,
    DATETIME_BEGIN = idle_begin,
    DATETIME_END   = idle_end,
    DISTANCE_PARCOURUE = NA_real_
  ) %>%
  ungroup()

# Create mirror events to explicitly represent interactions between patients and secondary actors
actor_mirror <- final_df %>%
  filter(
    TYPE == "PATIENT",
    !is.na(WITH_2)
  ) %>%
  transmute(
    ID = WITH_2,              
    TYPE = "ACTOR",
    CURRENT_LOCATION,
    NEXT_LOCATION,
    CURRENT_OPERATION_NUMBER,
    WITH_1 = NA_character_,
    WITH_2 = ID,                
    DATETIME_BEGIN,
    DATETIME_END = DATETIME_BEGIN,
    DISTANCE_PARCOURUE = NA_real_
  )

# Final complete trace
trace_full_complete <- bind_rows(
  final_df,
  actors_base,
  actor_idle,
  actor_mirror
) %>%
  arrange(ID, DATETIME_BEGIN)

trace_full_complete

trace_full_complete %>% filter(TYPE != "PATIENT")
```

**Résultat :**

On obtient donc une table avec les acteurs ajoutés et liés à leurs patients en récupérant l'ensemble de leurs déplacements et intéractions.
On télécharge ensuite le CSV :

```{r answer 1.a}

trace_full_complete <- trace_full_complete %>%
  mutate(
    DATETIME_BEGIN = format(as.POSIXct(DATETIME_BEGIN, tz = "UTC"),
                            "%Y-%m-%dT%H:%M:%SZ"),
    DATETIME_END   = format(as.POSIXct(DATETIME_END,   tz = "UTC"),
                            "%Y-%m-%dT%H:%M:%SZ")
  )
write.csv(
  trace_full_complete,
  file = "trace_full.csv",
  row.names = FALSE,
  fileEncoding = "UTF-8"
)
```

De plus, il vous est demandé d'identifier toutes les erreurs de données potentielles (s'il y en a) comme :

-   les valeurs manquantes avec la fonction *is_na()* (sans raison valable)

-   les valeurs aberrantes comme des distances trop grandes ou des temps trop longs

-   les valeurs incohérentes comme des chevauchements de dates ou des enchaînements incohérent d'activités

#### Réponse :

```{r answer 1.b}
library(readr)
library(dplyr)

df <- read_csv2(
  "local_data/trace_example_final.csv",
  show_col_types = FALSE,
  locale = locale(
    decimal_mark = ",",
    grouping_mark = "."
  )
)
# df

# a) Counting missing values by column
missing_summary <- tibble(
  Column = names(df),
  Missing_Values = colSums(is.na(df))
) %>%
  arrange(desc(Missing_Values))

missing_summary

# b) Outliers (distances too great or times too long)
# Create a new data frame with activity duration (in minutes)
df_aberrant <- df %>%
  mutate(
    duration_min = as.numeric(difftime(DATETIME_END, DATETIME_BEGIN, units = "mins")))

# Identify aberrant durations (negative or excessively long)
df_aberrant_time <- df_aberrant %>%
  filter(duration_min < 0 | duration_min > 480)

# Identify aberrant distances (negative or too large)
df_aberrant_distance <- df_aberrant %>%
  filter(DISTANCE_PARCOURUE < 0 | DISTANCE_PARCOURUE > 1000)

# c) Inconsistent values (date overlaps or inconsistent sequences)

# Incoherent dates: end before begin
df_incoherent_dates <- df %>%
  filter(DATETIME_END < DATETIME_BEGIN)

# Overlapping activities for the same patient
df_overlaps <- df %>%
  arrange(ID, DATETIME_BEGIN) %>%
  group_by(ID) %>%
  mutate(previous_end = lag(DATETIME_END)) %>%
  filter(DATETIME_BEGIN < previous_end) %>%
  ungroup()

cat("Number of events with aberrant time values: ", nrow(df_aberrant_time), "\n")
cat("Number of events with aberrant distance values: ", nrow(df_aberrant_distance), "\n")
cat("Number of events with incoherent dates: ", nrow(df_incoherent_dates), "\n")
cat("Number of overlapping events: ", nrow(df_overlaps), "\n")
```

L’analyse de la qualité des données a permis d’identifier différents types de problèmes potentiels dans le jeu de données :

1.  **Valeurs manquantes** : certaines colonnes présentent un nombre important de valeurs absentes, notamment `WITH_2` (2 790 valeurs manquantes) et `WITH_1` (2 028 valeurs manquantes), ce qui reflète l’absence d’interaction avec un acteur pour certaines opérations.
    Les colonnes `CURRENT_OPERATION_NUMBER` et `DISTANCE_PARCOURUE` contiennent également des valeurs manquantes, tandis que les colonnes critiques comme `ID`, `TYPE`, `DATETIME_BEGIN` et `DATETIME_END` sont complètes.

2.  **Valeurs aberrantes** : aucune valeur aberrante n’a été détectée pour les temps ou les distances, ce qui indique que les données numériques sont cohérentes avec les attentes opérationnelles.

3.  **Valeurs incohérentes** : aucune incohérence dans l’enchaînement des dates ou des opérations n’a été identifiée, à l’exception de **136 chevauchements d’événements**, qui représentent des situations où deux événements se produisent simultanément pour une même entité.
    Ces cas devront être étudiés plus en détail pour déterminer s’il s’agit d’un artefact de saisie ou d’un phénomène réel du processus.

Le jeu de données est globalement de bonne qualité pour l’analyse de processus, avec des données critiques complètes et un nombre limité de chevauchements à examiner.
Les valeurs manquantes pour les acteurs ou les distances peuvent être justifiées par la nature du processus et ne remettent pas en cause l’intégrité globale du log.

### Question 2) Dénombrements (/1)

Les premières analyses effectuées sur un jeu de données sont le plus souvent de simples dénombrement.

Ainsi il vous est demandé d'extraire les nombres : (*attention à la façon de compter*)

-   Nombre de patient

-   Nombre d'acteur

-   Nombre d’activités générales et détaillées

N'hésitez pas à discuter brièvement de ces nombres notamment en les comparant.

#### Réponse :

```{r answer 2}
library(dplyr)

# a) Number of unique patients
df_patients <- df %>%
  filter(TYPE == "PATIENT") %>%
  distinct(ID)

n_patients <- nrow(df_patients)

# b) Number of unique actors
df_actors <- df %>%
  filter(TYPE == "ACTOR") %>%
  distinct(ID)

n_actors <- nrow(df_actors)


# Number of general activities
df_counts <- read_excel("Log_Patient_URO_12112015.xlsx")
df_activities_general <- df_counts %>%
  distinct(Activity_MACRO)
n_activities_general <- nrow(df_activities_general)

# Number of detailed activities
df_activities_detailed <- df_counts %>%
  distinct(Activity_DETAILS)
n_activities_detailed <- nrow(df_activities_detailed)

# Summary
summary_counts <- data.frame(
  Indicator = c(
    "Number of patients",
    "Number of actors",
    "Number of general activities",
    "Number of detailed activities"
  ),
  Value = c(
    n_patients,
    n_actors,
    n_activities_general,
    n_activities_detailed
  )
)

summary_counts
```

#### Analyse

Le jeu de données comprend 68 patients pour 18 acteurs, soit environ 4 patients par acteur, ce qui est cohérent avec le fonctionnement d’un service ambulatoire où chaque acteur intervient auprès de plusieurs patients au cours de la journée.

On recense 14 activités générales et 24 activités détaillées, ce qui traduit une modélisation relativement fine du parcours patient.
Les activités générales décrivent les grandes étapes du processus, tandis que les activités détaillées permettent de distinguer les différentes zones et modalités opérationnelles.
Cette granularité est pertinente pour analyser les flux et les temps d’attente, mais elle implique une complexité accrue et nécessite de rester prudent lors de l’analyse d’activités peu représentées.

### Question 3) Analyse du patient le plus long (/1)

Il est souvent utile d'identifier les cas les plus extrêmes dans une population.

Ici, il vous est demandé d'identifier le patient avec le plus long temps de séjour et de :

-   de calculer son temps de séjour total

-   de calculer sa distance totale parcourue

-   de tenter d'analyser la cause de cette longueur, ou du moins de constater où se situe les phases responsables dans son parcours

N'hésitez pas à discuter brièvement de son parcours.

#### Réponse :

```{r answer 3}
library(readr)
library(dplyr)

#  Upload the original file
df_original <- read_csv2(
  "local_data/trace_example_final.csv",
  show_col_types = FALSE,
  locale = locale(
    decimal_mark = ",",
    grouping_mark = "."
  )
)

df_patients <- df_original %>%
  filter(TYPE == "PATIENT")

# Calculate the duration of each recording (in minutes)
df_patients <- df_patients %>%
  mutate(duration_min = as.numeric(difftime(DATETIME_END, DATETIME_BEGIN, units = "mins")))

# Calculate the total time and total distance per patient
df_patient_total <- df_patients %>%
  group_by(ID) %>%
  summarise(
    total_duration_min = sum(duration_min, na.rm = TRUE),
    total_distance = sum(DISTANCE_PARCOURUE, na.rm = TRUE)
  ) %>%
  ungroup()

# Identify the patient with the longest length of stay
patient_longest <- df_patient_total %>%
  filter(total_duration_min == max(total_duration_min))

patient_longest_tbl <- patient_longest %>%
  select(ID, total_duration_min, total_distance)

patient_longest_tbl

# To see where the cause lies 
df_long_patient <- df_patients %>%
  filter(ID == patient_longest$ID) %>%
  arrange(DATETIME_BEGIN)

df_long_patient %>% as.data.frame() 

write.csv(
  df_long_patient,
  file = "long_patient.csv",
  row.names = FALSE,
  fileEncoding = "UTF-8"
)
```

-   **Durée totale du séjour** : 354,25 minutes (\~5h54)

-   **Distance totale parcourue** : 22 079,53 mètres (\~22 km)

-   **Causes principales du long séjour** :

```         
-   Temps d’attente cumulés dans les salles d’attente (`Uro_Attente_1`)

-   Examens et consultations (`Uro_Examen_2`, `Uro_Bureau_Annonce_1`)
```

-   Les déplacements entre les lieux et les opérations rapides contribuent très peu à la durée totale.

### Question 4) Analyse des temps (/4)

On peut ensuite partir sur une analyse globale plus poussée sur :

-   Les temps de séjour et d'attente des patients

-   Les temps d'activité

Vous êtes libres d'aller explorer différents indicateurs, hypothèses de distributions (lois de probabilités).
Notamment quel ratio de temps les patients passent-ils à attendre ?
Il est fortement recommandé d'utiliser des plots pour votre exploration.
N'hésitez pas à faire ressortir les faits les plus marquant et à discuter brièvement des distributions que vous observerez.

#### Réponse :

```{r answer 4}

library(dplyr)
library(ggplot2)
library(readr) 

# Load the data
df_original <- read_csv2(
  "local_data/trace_example_final.csv",
  show_col_types = FALSE,
  locale = locale(
    decimal_mark = ",",
    grouping_mark = "."
  )
)

# Ensure that ID is a character
df_original$ID <- as.character(df_original$ID)

# Filter only patients and calculate duration per event
df_patients <- df_original %>%
  filter(TYPE == "PATIENT") %>%
  mutate(duration_min = as.numeric(difftime(DATETIME_END, DATETIME_BEGIN, units = "mins")))

# Summary per patient: total time, waiting time, and activity time
df_time_summary <- df_patients %>%
  group_by(ID) %>%
  summarise(
    total_time    = sum(duration_min, na.rm = TRUE),
    waiting_time  = sum(duration_min[grepl("Attente", CURRENT_LOCATION, ignore.case = TRUE)], na.rm = TRUE),
    activity_time = sum(duration_min[!grepl("Attente", CURRENT_LOCATION, ignore.case = TRUE)], na.rm = TRUE),
    waiting_ratio = waiting_time / total_time
  ) %>%
  ungroup()

# Summary
df_time_summary
summary(df_time_summary)

# Histogram of total length of stay
ggplot(df_time_summary, aes(x = total_time)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "black") +
  labs(title = "Distribution du temps total de séjour des patients", 
       x = "Temps total (min)", y = "Nombre de patients") +
  theme_minimal()

# Histogram of waiting time
ggplot(df_time_summary, aes(x = waiting_time)) +
  geom_histogram(bins = 30, fill = "orange", color = "black") +
  labs(title = "Distribution du temps d'attente des patients", 
       x = "Temps d'attente (min)", y = "Nombre de patients") +
  theme_minimal()

# Boxplot of the ratio of waiting time to total time
ggplot(df_time_summary, aes(y = waiting_ratio)) +
  geom_boxplot(fill = "purple", color = "black") +
  labs(title = "Ratio temps d'attente / temps total par patient", y = "Ratio") +
  theme_minimal()

# Scatter plot of total time vs. waiting time
ggplot(df_time_summary, aes(x = total_time, y = waiting_time)) +
  geom_point(alpha = 0.6, color = "darkgreen") +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(title = "Temps d'attente en fonction du temps total de séjour", 
       x = "Temps total (min)", y = "Temps d'attente (min)") +
  theme_minimal()


```

#### Analyse :

L’analyse de la distribution du temps total de séjour des patients met en évidence une forte asymétrie.
La majorité des patients présente un temps de séjour inférieur à 200 minutes, avec un pic marqué autour de 50 minutes, correspondant au fonctionnement nominal du service pour la plupart des parcours.
Toutefois, la présence de quelques cas extrêmes, avec des durées de séjour atteignant près de 350 minutes comme nous avons pu le voir dans la question précédente, révèle des situations atypiques susceptibles d’indiquer des phénomènes de congestion ou des dysfonctionnements ponctuels du processus.
Ces cas extrêmes contribuent significativement à l’augmentation de la moyenne globale.

La distribution du temps d’attente des patients présente une forme similaire, fortement asymétrique, avec une majorité de patients subissant des temps d’attente modérés, mais une minorité exposée à des attentes très élevées.
Cette dispersion importante traduit une variabilité marquée des parcours et met en évidence que, si le service fonctionne de manière acceptable pour la plupart des patients, certains parcours sont fortement pénalisés par des périodes d’attente prolongées.

L’analyse du ratio entre le temps d’attente et le temps total de séjour montre que l’attente représente une part significative du parcours patient.
La médiane de ce ratio se situe autour de 30 %, avec une dispersion relativement limitée entre les patients.
Ce résultat suggère que l’attente constitue une composante structurelle du fonctionnement du service, affectant de manière relativement homogène l’ensemble des patients, plutôt qu’un phénomène marginal limité à quelques cas isolés.

Enfin, l’étude de la relation entre le temps d’attente et le temps total de séjour met en évidence une corrélation linéaire forte.
Cette relation indique que l’allongement des temps de séjour est principalement dû à l’augmentation des temps d’attente, et non à une augmentation du temps d’activité.
Ainsi, les patients ayant les séjours les plus longs sont avant tout ceux qui subissent les attentes les plus importantes, ce qui confirme le rôle central de l’attente dans la dégradation de la performance globale du service.

### 5) Analyse du niveau d'occupation (/4)

Au delà des temps, l'analyse de la congestion d'un système se fait sur le niveau d'occupation.
Il vous est demandé d'identifier et si pertinent d'illustrer :

-   le niveau d'occupation à chaque instant de la journée analysée puis lissé sur 2h

-   le niveau d'occupation par blocs de 2h

-   le niveau d'occupation moyen sur la journée

L'évolution du niveau d'occupation étant une conséquence directe des arrivées et des départs.
Il vous est demandé de faire les mêmes analyses sur le nombre d'arrivées et de départs au cours de la journée et de le mettre en lien avec le niveau d'occupation.

#### Réponse :

```{r answer 5}
library(readr)
library(dplyr)
library(lubridate)
library(tidyr)
library(zoo)
library(ggplot2)

## Occupancy level at each moment, smoothed

# 1) Read data
df <- df_original <- read_csv2(
  "local_data/trace_example_final.csv",
  show_col_types = FALSE,
  locale = locale(
    decimal_mark = ",",
    grouping_mark = "."
  )
)

# 2) Convert dates + timezone
df <- df %>%
  mutate(
    DATETIME_BEGIN = with_tz(ymd_hms(DATETIME_BEGIN, tz = "UTC"), "Europe/Paris"),
    DATETIME_END   = with_tz(ymd_hms(DATETIME_END,   tz = "UTC"), "Europe/Paris")
  )

# 3) Build stays per patient
sejours_service <- df %>%
  filter(TYPE == "PATIENT") %>%
  group_by(ID) %>%
  summarise(
    entree = min(DATETIME_BEGIN, na.rm = TRUE),
    sortie = max(DATETIME_END,   na.rm = TRUE),
    .groups = "drop"
  )

# 4) Transform into events
arrivals <- sejours_service %>%
  transmute(datetime = entree, event =  1)

departures <- sejours_service %>%
  transmute(datetime = sortie, event = -1)

df_events <- bind_rows(arrivals, departures) %>%
  arrange(datetime)

# 5) Instantaneous occupancy
df_occupation <- df_events %>%
  mutate(occupation = cumsum(event))

# 6) Create a time grid (1-minute intervals)
time_grid <- tibble(
  datetime = seq(
    from = min(df_occupation$datetime),
    to   = max(df_occupation$datetime),
    by   = "1 min"
  )
)

# 7) Map occupation onto the grid
df_occupation_grid <- time_grid %>%
  mutate(
    occupation = df_occupation$occupation[
      findInterval(datetime, df_occupation$datetime)
    ]
  ) %>%
  mutate(
    occupation = ifelse(is.na(occupation), 0, occupation)
  )

# 8) 2-hour smoothing
df_occupation_grid <- df_occupation_grid %>%
  mutate(
    occupation_2h = rollmean(
      occupation,
      k = 24,        # 24 x 5 min = 2 hours if time step = 5 min, adjust if needed
      align = "center",
      fill = NA
    )
  )

# 9) Visualization (labels in French)
ggplot(df_occupation_grid, aes(x = datetime)) +
  geom_line(aes(y = occupation), 
            color = "grey70", 
            linewidth = 0.6) +
  geom_line(aes(y = occupation_2h), 
            color = "steelblue", 
            linewidth = 1) +
  labs(
    title = "Niveau d’occupation du service",
    subtitle = "Occupation instantanée (gris) et lissée sur 2h (bleu)",
    x = "Temps",
    y = "Nombre de patients présents"
  )

## Occupancy level per 2-hour block

# Map onto 2-hour blocks
occupation_2h_blocs <- df_occupation_grid %>%
  mutate(
    bloc_2h = floor_date(datetime, unit = "2 hours")
  ) %>%
  group_by(bloc_2h) %>%
  summarise(
    nb_patients_moyen = mean(occupation),
    .groups = "drop"
  )

# Visualization (labels in French)
ggplot(occupation_2h_blocs, aes(x = bloc_2h, y = nb_patients_moyen)) +
  geom_col(fill = "steelblue") +
  labs(
    title = "Nombre moyen de patients présents par blocs de 2h",
    x = "Créneau horaire",
    y = "Patients (moyenne sur 2h)"
  )

## Average occupancy over the day

occupation_journee <- df_occupation_grid %>%
  summarise(
    nb_patients_moyen_jour = mean(occupation)
  )

tableau_occupation_jour <- df_occupation_grid %>%
  summarise(
    `Occupation moyenne journalière` = round(mean(occupation), 2)
  )

tableau_occupation_jour

## Analysis of arrivals and departures

arrivees_2h <- arrivals %>%
  mutate(bloc_2h = floor_date(datetime, "2 hours")) %>%
  count(bloc_2h, name = "nb_arrivees")

departs_2h <- departures %>%
  mutate(bloc_2h = floor_date(datetime, "2 hours")) %>%
  count(bloc_2h, name = "nb_departs")

flux_2h <- full_join(arrivees_2h, departs_2h, by = "bloc_2h") %>%
  replace_na(list(nb_arrivees = 0, nb_departs = 0)) %>%
  mutate(flux_net = nb_arrivees - nb_departs)

# Visualization (labels in French)
ggplot(flux_2h, aes(x = bloc_2h)) +
  geom_col(aes(y = nb_arrivees), fill = "darkgreen") +
  geom_col(aes(y = -nb_departs), fill = "firebrick") +
  labs(
    title = "Arrivées et départs par blocs de 2 heures",
    x = "Créneau horaire",
    y = "Flux de patients (+ arrivées / − départs)"
  )

```

#### Analyse des résultats

L’analyse du niveau d’occupation du service met en évidence une dynamique journalière marquée liée aux flux d’arrivées et de départs des patients.

Le niveau d’occupation instantané montre une montée progressive en début de matinée, suivie de deux phases de congestion distinctes.
La première apparaît en fin de matinée, tandis que la seconde, plus prononcée, se situe en milieu d’après-midi.
Le lissage sur une fenêtre de 2 heures permet de faire ressortir clairement ces tendances en atténuant les fluctuations de court terme.
Le nombre maximal de patients présents simultanément atteint environ 20 patients.

L’occupation moyenne sur l’ensemble de la journée est de 9,14 patients.
Cette valeur,inférieure aux niveaux observés lors des pics, souligne une forte variabilité temporelle de la charge du système.
Le service fonctionne donc une part significative du temps au-dessus de sa charge moyenne, ce qui peut constituer un facteur de tension opérationnelle lors des périodes de pointe.

L’analyse des arrivées et des départs par blocs de 2 heures permet d’expliquer ces variations.
En début de journée, le nombre d’arrivées est supérieur au nombre de départs, entraînant une accumulation progressive de patients et une augmentation du niveau d’occupation.
En fin de matinée et en début d’après-midi, les départs augmentent mais ne compensent pas totalement les arrivées, ce qui conduit à un maintien de l’occupation à un niveau élevé.
En revanche, en fin d’après-midi et en soirée, les départs deviennent majoritaires tandis que les arrivées diminuent fortement, ce qui provoque une décroissance rapide de l’occupation jusqu’à la fermeture progressive du service.

Ainsi, l’évolution du niveau d’occupation apparaît comme la conséquence directe du déséquilibre temporaire entre arrivées et départs.
Les périodes de congestion identifiées correspondent à des phases de flux net entrant positif, tandis que la décrue observée en fin de journée est associée à un flux net sortant.
Cette cohérence entre flux et occupation valide la pertinence des indicateurs utilisés et met en évidence des créneaux horaires critiques sur lesquels une optimisation organisationnelle pourrait être envisagée.

### 6) Analyse de l'activité des acteurs (/4)

De manière similaire avec la question 3 pour le patient le plus long, il vous est demandé d'analyser l'activité des acteurs par type d'acteur.
On considéra que les acteurs arrivent dans le service 5 min avant leur première activité et partent 5 min après leur dernière activité.

#### Réponse :

```{r answer 6}
library(ggplot2)
library(lubridate)

df_original <- df_original <- read_csv2(
  "local_data/trace_example_final.csv",
  show_col_types = FALSE,
  locale = locale(
    decimal_mark = ",",
    grouping_mark = "."
  )
)

df_actors_loc <- df_original %>%
  filter(TYPE == "ACTOR") %>%
  mutate(
    ACTOR_TYPE_INFERRED = case_when(
      grepl("^Accueil", CURRENT_LOCATION, ignore.case = TRUE) ~ "Accueil",
      grepl("Uro_Box", CURRENT_LOCATION, ignore.case = TRUE) ~ "Medecin",
      grepl("Uro_Examen", CURRENT_LOCATION, ignore.case = TRUE) ~ "Medecin",
      grepl("Uro_Bureau_IDE", CURRENT_LOCATION, ignore.case = TRUE) ~ "IDE",
      grepl("Uro_Debimetrie", CURRENT_LOCATION, ignore.case = TRUE) ~ "IDE_Technique",
      grepl("Uro_Bureau_Annonce", CURRENT_LOCATION, ignore.case = TRUE) ~ "Medecin",
      TRUE ~ "Autre"
    )
  )

df_actors_loc

# Verification
table(df_actors_loc$ACTOR_TYPE_INFERRED)

df_actor_presence <- df_actors_loc %>%
  group_by(ID, ACTOR_TYPE_INFERRED) %>%
  summarise(
    first_activity = min(DATETIME_BEGIN, na.rm = TRUE),
    last_activity  = max(DATETIME_END, na.rm = TRUE),
    total_presence_min = as.numeric(
      difftime(last_activity + minutes(5),
               first_activity - minutes(5),
               units = "mins")
    ),
    .groups = "drop"
  )

df_actor_summary <- df_actor_presence %>%
  group_by(ACTOR_TYPE_INFERRED) %>%
  summarise(
    nb_actors = n(),
    mean_presence = mean(total_presence_min, na.rm = TRUE),
    median_presence = median(total_presence_min, na.rm = TRUE),
    max_presence = max(total_presence_min, na.rm = TRUE),
    .groups = "drop"
  )

df_actor_summary


ggplot(df_actor_presence,
       aes(x = ACTOR_TYPE_INFERRED, y = total_presence_min)) +
  geom_boxplot() +
  labs(
    title = "Actors' presence time by inferred actor type",
    x = "Inferred actor type",
    y = "Total presence time (minutes)"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Analyse du diagramme

L’analyse des temps de présence des acteurs par type met en évidence une forte hétérogénéité organisationnelle au sein du service.
Les acteurs de l’accueil présentent des temps de présence élevés et relativement homogènes, traduisant un rôle continu et structurant, nécessaire sur l’ensemble de la plage d’ouverture du service.
À l’inverse, les infirmiers (IDE) affichent des durées de présence plus courtes et plus dispersées, ce qui suggère des interventions ponctuelles ou spécialisées, possiblement liées à des actes techniques ou à des rotations d’équipe.
Les médecins se distinguent par une très forte variabilité de leurs temps de présence, certains n’intervenant que sur des créneaux limités tandis que d’autres restent présents sur une grande partie de la journée.
Cette dispersion indique des pratiques professionnelles hétérogènes et fait des médecins un facteur majeur de variabilité dans l’organisation du service.
Enfin, la catégorie « Autre », bien que moins précisément caractérisée, présente des temps de présence élevés, suggérant des fonctions de coordination ou de support transversal.
Dans l’ensemble, ces résultats soulignent une organisation différenciée des rôles, où certains acteurs assurent une continuité opérationnelle tandis que d’autres interviennent de manière plus flexible, contribuant à la dynamique globale du système.
